diff --git a/node_modules/react-three-fiber/native.js b/node_modules/react-three-fiber/native.js
index 77115b1..7c23bf2 100644
--- a/node_modules/react-three-fiber/native.js
+++ b/node_modules/react-three-fiber/native.js
@@ -669,6 +669,7 @@ const useCanvas = props => {
     const hits = intersect(event, false); // If the interaction is captured take that into account, the captured event has to be part of the intersects
 
     if (state.current.captured && event.type !== 'click' && event.type !== 'wheel') {
+
       state.current.captured.forEach(captured => {
         if (!hits.find(hit => hit.eventObject === captured.eventObject)) hits.push(captured);
       });
@@ -762,12 +763,13 @@ const useCanvas = props => {
             type: 'pointerleave'
           }));
         }
-
         hovered.delete(makeId(data));
       }
     });
+
   }, []);
   const handlePointer = useCallback(name => event => {
+    event.type = name;
     state.current.pointer.emit(name, event); // Collect hits
 
     const hits = handleIntersects(event, data => {
@@ -777,10 +779,11 @@ const useCanvas = props => {
       if (handlers && handlers[name]) {
         // Forward all events back to their respective handlers with the exception of click,
         // which must must the initial target
+
         if (name !== 'click' || state.current.initialHits.includes(eventObject)) handlers[name](data);
+   
       }
     }); // If a click yields no results, pass it back to the user as a miss
-
     if (name === 'pointerDown') {
       state.current.initialClick = [event.clientX, event.clientY];
       state.current.initialHits = hits.map(hit => hit.eventObject);
@@ -799,7 +802,7 @@ const useCanvas = props => {
       onPointerLeave: e => handlePointerCancel(e, []),
       onPointerMove: handlePointerMove,
       onGotPointerCapture: e => state.current.captured = intersect(e, false),
-      onLostPointerCapture: e => (state.current.captured = undefined, handlePointerCancel(e))
+      onLostPointerCapture: e => (state.current.captured = undefined, handlePointerCancel(e,[]))
     };
   }, [onPointerMissed]);
   /** Events ------------------------------------------------------------------------------------------------- */
@@ -1001,7 +1004,7 @@ const IsReady = memo((_ref) => {
   const events = useCanvas(_extends({}, props, {
     gl
   }));
-  let pointerDownCoords = null;
+  let pointerDownCoords = useRef(null);
   const panResponder = useMemo(() => PanResponder.create({
     onStartShouldSetPanResponderCapture(e) {
       events.onGotPointerCapture(clientXY(e));
@@ -1013,30 +1016,37 @@ const IsReady = memo((_ref) => {
     onMoveShouldSetPanResponderCapture: () => true,
     onPanResponderTerminationRequest: () => true,
     onPanResponderStart: e => {
-      pointerDownCoords = [e.nativeEvent.locationX, e.nativeEvent.locationY];
+      pointerDownCoords.current = [e.nativeEvent.locationX, e.nativeEvent.locationY];
       events.onPointerDown(clientXY(e));
+
     },
     onPanResponderMove: e => events.onPointerMove(clientXY(e)),
     onPanResponderEnd: e => {
       events.onPointerUp(clientXY(e));
 
-      if (pointerDownCoords) {
-        const xDelta = pointerDownCoords[0] - e.nativeEvent.locationX;
-        const yDelta = pointerDownCoords[1] - e.nativeEvent.locationY;
+      if (  pointerDownCoords.current ) {
         
+        const xDelta =  pointerDownCoords.current [0] - e.nativeEvent.locationX;
+        const yDelta =  pointerDownCoords.current [1] - e.nativeEvent.locationY;
         if (Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2)) < CLICK_DELTA) {
           events.onClick(clientXY(e));
         }
       }
 
-      pointerDownCoords = null;
+      pointerDownCoords.current  = null;
+    },
+    onPanResponderRelease: e => {
+      events.onPointerLeave(clientXY(e))
+    },
+    onPanResponderTerminate: e =>{
+      events.onLostPointerCapture(clientXY(e))
     },
-    onPanResponderRelease: e => events.onPointerLeave(clientXY(e)),
-    onPanResponderTerminate: e => events.onLostPointerCapture(clientXY(e)),
-    onPanResponderReject: e => events.onLostPointerCapture(clientXY(e))
+    onPanResponderReject: e => {
+      events.onLostPointerCapture(clientXY(e))
+    }
   }), []);
   return createElement(View, _extends({}, panResponder.panHandlers, {
-    style: StyleSheet.absoluteFill
+    style: [StyleSheet.absoluteFill, {zIndex: 9999}]
   }));
 });
 const Canvas = memo(props => {
@@ -1072,7 +1082,7 @@ const Canvas = memo(props => {
 
     if (props.shadowMap) {
       // https://github.com/expo/expo-three/issues/38
-      gl.createRenderbuffer = () => ({});
+    
     }
 
     const pixelRatio = PixelRatio.get();
